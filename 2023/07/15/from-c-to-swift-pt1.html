<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>From C to Swift - Part 1</title>
  
  <meta name="description" content="Learn to how to integrate C system libraries into your Swift code">
  
  <meta name="author" content="Inal Gotov">

  <link rel="stylesheet" href="/assets/css/styles.css?v=1.0">

  <link type="application/atom+xml" rel="alternate" href="https://inalgotov.com/feed.xml" title="Inal&apos;s Gotov" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>From C to Swift - Part 1 | Inal’s Gotov</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="From C to Swift - Part 1" />
<meta name="author" content="Inal Gotov" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Learn to how to integrate C system libraries into your Swift code" />
<meta property="og:description" content="Learn to how to integrate C system libraries into your Swift code" />
<link rel="canonical" href="https://inalgotov.com/2023/07/15/from-c-to-swift-pt1.html" />
<meta property="og:url" content="https://inalgotov.com/2023/07/15/from-c-to-swift-pt1.html" />
<meta property="og:site_name" content="Inal’s Gotov" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-07-15T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="From C to Swift - Part 1" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Inal Gotov"},"dateModified":"2023-07-15T00:00:00+00:00","datePublished":"2023-07-15T00:00:00+00:00","description":"Learn to how to integrate C system libraries into your Swift code","headline":"From C to Swift - Part 1","mainEntityOfPage":{"@type":"WebPage","@id":"https://inalgotov.com/2023/07/15/from-c-to-swift-pt1.html"},"url":"https://inalgotov.com/2023/07/15/from-c-to-swift-pt1.html"}</script>
<!-- End Jekyll SEO tag -->


</head>

<body>

  <article class="readingMargins">
  <h1>From C to Swift - Part 1</h1>

  <p class="date">Written on Jul 15, 2023</p>

  

  <p>In this article I will walk you through the steps required to set up a C library as a SwiftPM package. This will allow you to use C code within a Swift project. I will then also show you how to use said C code from Swift, as well as how to make it more Swift-friendly.</p>

<p>Throughout this article I will be showing you various examples, using the <a href="https://en.wikipedia.org/wiki/Ncurses">ncurses</a> library. This is a library that is used for more advanced cases of putting text on the terminal screen. I had the pleasure of playing around with it in one of my recent side projects. It should come pre-installed on most *nix systems, including macOS (though not necessarily on iOS). If you wish to follow along with me using <code class="language-plaintext highlighter-rouge">ncurses</code>, I recommend building for macOS.</p>

<h2 id="setup-swiftpm-package">Setup SwiftPM package</h2>

<p>You can create the package through whatever means work best for you. One way to do it is through the <code class="language-plaintext highlighter-rouge">Swift Package</code> Xcode template, found in the <code class="language-plaintext highlighter-rouge">Multiplatform</code> tab, when creating a new project. Another way is to use the terminal to navigate to the directory where you want your package to be stored and running the command:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">swift package init <span class="nt">--type</span> library</code></pre></figure>

<p>This will initialize a new SwiftPM package in the current working directory. It will name the package the same as the name of the current directory. In my case I initialized it in a <code class="language-plaintext highlighter-rouge">Curses</code> directory, so that will be the name of the package. It will be a library, so it can be imported into other packages.</p>

<p>Once the package is created, we can open it in Xcode for editing, by double clicking the <code class="language-plaintext highlighter-rouge">Package.swift</code> file or running <code class="language-plaintext highlighter-rouge">open Package.swift</code> in the terminal.</p>

<h2 id="importing-ncurses">Importing <code class="language-plaintext highlighter-rouge">ncurses</code></h2>

<p>Importing a C library consists of a number of steps.</p>

<ol>
  <li>Create a library source directory with a bridging header and a <code class="language-plaintext highlighter-rouge">modulemap</code> file.</li>
  <li>Define a <code class="language-plaintext highlighter-rouge">systemLibrary</code> target in the SwiftPM manifest file.</li>
  <li>Add the <code class="language-plaintext highlighter-rouge">systemLibrary</code> target as a dependency to the target where we wish to use the library.</li>
</ol>

<p>After that you simply import the library and use it as you would.</p>

<h3 id="create-source-directory">Create source directory</h3>

<p>Let’s get started, first we create a directory to hold the “sources” of our library. This directory can by anywhere really, but keep in mind that we will need to reference in the next step, relative to the <code class="language-plaintext highlighter-rouge">Package</code> file’s location. I will put mine in the <code class="language-plaintext highlighter-rouge">Sources</code> directory. The library I am using is called <code class="language-plaintext highlighter-rouge">ncurses</code>. Swift conventions recommend you prepend a <code class="language-plaintext highlighter-rouge">C</code> to the names of C libraries to make it clear that they are not Swift libraries. Therefore I will call my directory <code class="language-plaintext highlighter-rouge">Cncurses</code>. You can call it something else if you wish, but take note of the name as we will reference it later.</p>

<p>Next we will create two files in this directory. The first is a bridging header. It will be a C header file. That is, a plain-text file ending with the <code class="language-plaintext highlighter-rouge">.h</code> extension. The name of the file doesn’t really matter. I will call mine <code class="language-plaintext highlighter-rouge">bridging-header.h</code>, since it technically acts as a bridge between the C and Swift interfaces. In this bridging header we must import any C code that we wish to be a part of this Swift Package. These imports are done in C syntax and look as follows:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;libraryHeader&gt;</span></code></pre></figure>

<p>You can import individual C files here if you wish, however for most libraries there will be what’s called an “umbrella” header, which will import all the public headers that are part of the library. Most things that you import here will have the <code class="language-plaintext highlighter-rouge">.h</code> extension, same as our own header file.</p>

<p>In my case I am trying to import the <code class="language-plaintext highlighter-rouge">ncurses</code> library, so I will do it like so:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;ncurses.h&gt;</span></code></pre></figure>

<aside class="info "><h1>Info </h1>
<p>If you are unfamiliar with C there is one thing that is good to know. C and Swift work a little different in terms of how they share code between source files.</p>

<p>In swift we are used to having access to all the code that is within the same module. For code outside of our module, we can simply import the whole module and we get access to all public members. For example, if you are working on an app, all code that belongs to the app can freely reference each other (so long as it has an access level of <code class="language-plaintext highlighter-rouge">internal</code> of higher). However for code defined outside of our app, such as in the <code class="language-plaintext highlighter-rouge">UIKit</code>, <code class="language-plaintext highlighter-rouge">SwiftUI</code> and <code class="language-plaintext highlighter-rouge">Foundation</code> frameworks or some third-party library such as <code class="language-plaintext highlighter-rouge">Firebase</code> or <code class="language-plaintext highlighter-rouge">Realm</code>, we must first import those modules, before we can use their code.</p>

<p>C works a little different. Everything declared in a <code class="language-plaintext highlighter-rouge">.c</code> source code file is private by default. You make it public by also including forward declarations of its members in an accompanying header file. A forward declaration is similar to how a protocol declaration looks (though that’s where the similarities end, C does not have objects or protocols). Other source code can then import whatever headers they need, to use code from other source code files. With this difference in mind it is easy to see that these two systems are not really compatible out of the box.</p>

<p>This is why we must use a bridging header to <strong>bridge</strong> the gap between the two systems. We define one or more headers that import all the code that our Swift module needs to use. Swift will then treat that bridging header as one module, that you can import. If you have a mixed Swift/Objective-C codebase, you will have a bridging header generated for you by Xcode that performs the same function. That bridging header will imported implicitly. In our case we will need to import it manually.</p>
</aside>

<p>Next, we define a <code class="language-plaintext highlighter-rouge">modulemap</code> file.</p>

<p>Create a new file called <code class="language-plaintext highlighter-rouge">module.modulemap</code>. This file is responsible for telling SwiftPM what your package consists of. The file name is important. Place the following inside of the file.</p>

<figure class="highlight"><pre><code class="language-modulemap" data-lang="modulemap"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre>module SwiftLibraryName {
    header "bridgingHeaderName"
    link "CLibraryName"
    export *
}
</pre></td></tr></tbody></table></code></pre></figure>

<p>Make sure to replace the following:</p>

<ul>
  <li>Replace <code class="language-plaintext highlighter-rouge">SwiftLibraryName</code> with the Swift facing name for your library. Remember that Swift conventions recommend C library names to be prepended with a “C”. In my case I will name the library <code class="language-plaintext highlighter-rouge">Cncurses</code>.</li>
  <li>Replace <code class="language-plaintext highlighter-rouge">bridgingHeaderName</code> with the file name that you used for the bridging header, including the file extension. In my case that is <code class="language-plaintext highlighter-rouge">bridging-header.h</code>.</li>
  <li>Replace <code class="language-plaintext highlighter-rouge">CLibraryName</code> with the name of the library, as it appears in C, typically that will be the name of the umbrella header without the <code class="language-plaintext highlighter-rouge">.h</code> extension. In my case that is <code class="language-plaintext highlighter-rouge">ncurses</code>.</li>
</ul>

<p>After the replacements my <code class="language-plaintext highlighter-rouge">modulemap</code> file looks something like this:</p>

<figure class="highlight"><pre><code class="language-modulemap" data-lang="modulemap"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre>module Cncurses {
    header "bridging-header.h"
    link "ncurses"
    export *
}
</pre></td></tr></tbody></table></code></pre></figure>

<p>We’ve defined what our system library must look like. Now we must make it visible to SwiftPM.</p>

<h3 id="define-swiftpm-systemlibrary-target">Define SwiftPM <code class="language-plaintext highlighter-rouge">systemLibrary</code> target</h3>

<p>Open the <code class="language-plaintext highlighter-rouge">Package.swift</code> file. We will be adding a system library target here. This can be done with the <code class="language-plaintext highlighter-rouge">.systemLibrary(...)</code> static initializer. This initializer can take a number of arguments, but we will only be use two: <code class="language-plaintext highlighter-rouge">name</code> and <code class="language-plaintext highlighter-rouge">path</code>. For the <code class="language-plaintext highlighter-rouge">name</code> argument, make sure that it matches the <code class="language-plaintext highlighter-rouge">SwiftLibraryName</code> name that you used in your <code class="language-plaintext highlighter-rouge">modulemap</code> file. The <code class="language-plaintext highlighter-rouge">path</code> argument specifies a path to the folder that contains your source code, in our case the bridging header and the module map file. This path is relative to the location of the <code class="language-plaintext highlighter-rouge">Package.swift</code> file. You may be able to omit the <code class="language-plaintext highlighter-rouge">path</code> argument and have SwiftPM automatically resolve it, but I find specifying it manually works a little better.</p>

<p>With all of that in mind, my target definition will look like <code class="language-plaintext highlighter-rouge">.systemLibrary(name: "Cncurses", path: "Sources/Cncurses")</code>. We can now insert this definition in the <code class="language-plaintext highlighter-rouge">targets</code> array of the package definition. This is what my <code class="language-plaintext highlighter-rouge">Package.swift</code> file looks like, after the additions (unrelated code removed for brevity).</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">package</span> <span class="o">=</span> <span class="kt">Package</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"Curses"</span><span class="p">,</span>
    <span class="nv">products</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="p">],</span>
    <span class="nv">targets</span><span class="p">:</span> <span class="p">[</span>
        <span class="o">.</span><span class="nf">target</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Curses"</span><span class="p">),</span>
        <span class="c1">// New target</span>
        <span class="o">.</span><span class="nf">systemLibrary</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Cncurses"</span><span class="p">,</span> <span class="nv">path</span><span class="p">:</span> <span class="s">"Sources/Cncurses"</span><span class="p">),</span>
    <span class="p">]</span>
<span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If you are using Xcode, save the file and it will attempt to resolve the packages.</p>

<p>All the names here look confusing, so let me just clear it up a little. <code class="language-plaintext highlighter-rouge">Cncurses</code> is the name of my raw C library that I am exposing to Swift code through a SwiftPM package. <code class="language-plaintext highlighter-rouge">Curses</code> is the name of my Swift package that will internally be using <code class="language-plaintext highlighter-rouge">Cncurses</code> (the raw C library).</p>

<p>The next and last step is to add it as a dependency to some other target where we wish to use the library. In my case I only want to use it in the main <code class="language-plaintext highlighter-rouge">Curses</code> target so I will modify my <code class="language-plaintext highlighter-rouge">Package.swift</code> file to add a <code class="language-plaintext highlighter-rouge">Cncurses</code> dependency on the <code class="language-plaintext highlighter-rouge">Curses</code> target:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">package</span> <span class="o">=</span> <span class="kt">Package</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"Curses"</span><span class="p">,</span>
    <span class="nv">products</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="p">],</span>
    <span class="nv">targets</span><span class="p">:</span> <span class="p">[</span>
    <span class="o">.</span><span class="nf">target</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Curses"</span><span class="p">,</span> <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="s">"Cncurses"</span><span class="p">]),</span>  <span class="c1">// Add dependency here</span>
        <span class="o">.</span><span class="nf">systemLibrary</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Cncurses"</span><span class="p">,</span> <span class="nv">path</span><span class="p">:</span> <span class="s">"Sources/Cncurses"</span><span class="p">),</span>
    <span class="p">]</span>
<span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>With all that in place, I can now use the C library in the main <code class="language-plaintext highlighter-rouge">Curses</code> target. I can test this by simply importing the library and checking that the target compiles successfully.</p>

<p>In <code class="language-plaintext highlighter-rouge">main.swift</code></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">import</span> <span class="kt">Cncurses</span></code></pre></figure>

<p>If you are using Xcode, try to build the project and see if that succeeds. If you are using the terminal to build the project, you can use <code class="language-plaintext highlighter-rouge">swift build</code>. Your output should look similar to this:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"> % swift build
Building <span class="k">for </span>debugging...
<span class="o">[</span>2/2] Compiling Curses Curses.swift
Build <span class="nb">complete</span><span class="o">!</span> <span class="o">(</span>1.55s<span class="o">)</span>
 %</code></pre></figure>

<p>Now the C library is imported and you can use all of its compatible member. This is the end of part 1. In <a href="/2023/07/15/from-c-to-swift-pt2.html">part 2</a>, we will go through what using this library is actually like, as well as some tips on how to wrap the C API behind a more Swift-friendly interface.</p>

<h2 id="sources">Sources</h2>

<ul>
  <li><a href="https://rderik.com/blog/making-a-c-library-available-in-swift-using-the-swift-package/">Making a C library available in Swift using the Swift Package Manager | rderik</a></li>
  <li><a href="https://rderik.com/blog/building-a-text-based-application-using-swift-and-ncurses/">Building a text-based application using Swift and ncurses | rderik</a></li>
  <li><a href="https://github.com/rderik/SwiftCursesTerm">rderik/SwiftCursesTerm | GitHub</a></li>
  <li><a href="https://github.com/TheCoderMerlin/Curses/">TheCoderMerlin/Curses | GitHub</a></li>
</ul>

</article>

  <footer>
  © 2023 Inal Gotov
  <br>
  <a href="/index.html">Home</a> | <a href="/articles.html">Articles</a> | <a href="/feed.xml">RSS</a>
  <br>
  <a href="/privacy.html">Privacy Policy</a> | <a href="/assets/Inal_Gotov.pdf">Résumé</a>
</footer>

</body>
</html>

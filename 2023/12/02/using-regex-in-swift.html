<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Using Regex in Swift</title>
  
  <meta name="description" content="An in-depth look at the various different ways to define and use regular expressions in Swift">
  
  <meta name="author" content="Inal Gotov">

  <link rel="stylesheet" href="/assets/css/styles.css?v=1.0">

  <link type="application/atom+xml" rel="alternate" href="https://inalgotov.com/feed.xml" title="Inal Gotov" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Using Regex in Swift | Inal Gotov</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Using Regex in Swift" />
<meta name="author" content="Inal Gotov" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An in-depth look at the various different ways to define and use regular expressions in Swift" />
<meta property="og:description" content="An in-depth look at the various different ways to define and use regular expressions in Swift" />
<link rel="canonical" href="https://inalgotov.com/2023/12/02/using-regex-in-swift.html" />
<meta property="og:url" content="https://inalgotov.com/2023/12/02/using-regex-in-swift.html" />
<meta property="og:site_name" content="Inal Gotov" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-12-02T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Using Regex in Swift" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Inal Gotov"},"dateModified":"2023-12-02T00:00:00+00:00","datePublished":"2023-12-02T00:00:00+00:00","description":"An in-depth look at the various different ways to define and use regular expressions in Swift","headline":"Using Regex in Swift","mainEntityOfPage":{"@type":"WebPage","@id":"https://inalgotov.com/2023/12/02/using-regex-in-swift.html"},"url":"https://inalgotov.com/2023/12/02/using-regex-in-swift.html"}</script>
<!-- End Jekyll SEO tag -->


  <script src="https://kit.fontawesome.com/bae51c7054.js" crossorigin="anonymous"></script>
  
</head>

<body>

  <article class="readingMargins">
  <h1>Using Regex in Swift</h1>

  <p class="date">Written on Dec  2, 2023</p>

  
  
  <p class="tldr-prompt">Short on time? <a href="/tldr/2023-12-02-using-regex-in-swift.html">View the TLDR version here</a></p>
  

  <p>In this article I will be walking you through the various different ways to define and use regular expressions in Swift.</p>

<p>Throughout this article I will be using the following string as the sample text we are trying to parse with Regex. It is an example of a basic CSV table that one might encounter in their day-to-day work. I stole this example text from <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0350-regex-type-overview.md">here</a> because it’s a very good example that shows the flexibility of Regex in Swift.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">input</span> <span class="o">=</span> <span class="s">"""
CREDIT    03/02/2022    Payroll                   $200.23
CREDIT    03/03/2022    Sanctioned Individual A   $2,000,000.00
DEBIT     03/03/2022    Totally Legit Shell Corp  $2,000,000.00
DEBIT     03/05/2022    Beanie Babies Forever     $57.33
"""</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Let’s get started.</p>

<h2 id="nsregularexpression"><code class="language-plaintext highlighter-rouge">NSRegularExpression</code></h2>

<p>If your project is targeting platforms before iOS 16, then you’ll have no choice but to use Foundation’s Regex APIs. These are available since iOS 4.0 and were originally made for Objective-C. As a result they’re a little tedious to use in Swift.</p>

<p>If we wanted to define a regex pattern to grab the value of first column in the table, we would do it like so.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">NSRegularExpression</span><span class="p">(</span><span class="nv">pattern</span><span class="p">:</span> <span class="s">"(CREDIT|DEBIT)</span><span class="se">\\</span><span class="s">s+"</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This gives us an <code class="language-plaintext highlighter-rouge">NSRegularExpression</code> object. We have to <code class="language-plaintext highlighter-rouge">try</code> the initializer because if the string that we pass in happens to be invalid Regex it will throw an error.</p>

<p>Notice the double back slash in <code class="language-plaintext highlighter-rouge">\\s+</code>. We can avoid having to escape the backslash by using <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters/#Extended-String-Delimiters">extended string delimiters</a>. A special feature in swift that allows us to use a more specific string delimiter rather than just double quotes. With this, our regex pattern looks as follows:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">NSRegularExpression</span><span class="p">(</span><span class="nv">pattern</span><span class="p">:</span> <span class="err">#</span><span class="s">"(CREDIT|DEBIT)</span><span class="err">\</span><span class="s">s+"</span><span class="err">#</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>To actually use the regex on our string, we have to call methods on the <code class="language-plaintext highlighter-rouge">regex</code> object such as <code class="language-plaintext highlighter-rouge">firstMatch(in:options:range:)</code>, <code class="language-plaintext highlighter-rouge">matches(in:options:range:)</code> or <code class="language-plaintext highlighter-rouge">enumerateMatches(in:options:range:using:)</code>. For example</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="n">regex</span><span class="o">.</span><span class="nf">enumerateMatches</span><span class="p">(</span>
  <span class="nv">in</span><span class="p">:</span> <span class="n">input</span><span class="p">,</span>
  <span class="nv">range</span><span class="p">:</span> <span class="kt">NSRangeFromString</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
<span class="p">)</span> <span class="p">{</span> <span class="n">result</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">stopPointer</span> <span class="k">in</span>
  <span class="c1">// Do something with result</span>

  <span class="c1">// Stop early if needed</span>
  <span class="k">let</span> <span class="nv">shouldStop</span> <span class="o">=</span> <span class="kc">false</span>
  <span class="k">if</span> <span class="n">shouldStop</span> <span class="p">{</span>
    <span class="n">stopPointer</span><span class="o">.</span><span class="n">pointee</span> <span class="o">=</span> <span class="kc">false</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This API is a little bulky and dated in my opinion. I wont spend much more time exploring it. If you want to find out more, <a href="https://developer.apple.com/documentation/foundation/nsregularexpression">check out the docs</a>.</p>

<h2 id="regex"><code class="language-plaintext highlighter-rouge">Regex</code></h2>

<p>Starting with iOS 16.0 Swift has a new <code class="language-plaintext highlighter-rouge">Regex</code> type as part of its standard library. You can use this type much like you used the <code class="language-plaintext highlighter-rouge">NSRegularExpression</code> type above to define a regex pattern with a string literal.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">Regex</span><span class="p">(</span><span class="err">#</span><span class="s">"(CREDIT|DEBIT)</span><span class="err">\</span><span class="s">s+"</span><span class="err">#</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The usage of our regex type is a little different. The <code class="language-plaintext highlighter-rouge">Regex</code> object exposes a few method that you can use to parse a string, however the bulk of the API is defined on <code class="language-plaintext highlighter-rouge">String</code>. If we want to get the first match on our input string, we would do it like so.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">match</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="nf">firstMatch</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">regex</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This returns a <code class="language-plaintext highlighter-rouge">Regex.Match</code> object that we can use to query the output of our regex pattern. You can then use <code class="language-plaintext highlighter-rouge">match.output</code> to get the output of the regex.</p>

<p>So far this is not much different than what we had before. We still have to provide a string literal, and we still have to <code class="language-plaintext highlighter-rouge">try</code> the initializer, as it might fail if the regex is invalid. However this new API has some hidden improvements that we haven’t made use of yet.</p>

<h3 id="output-types">Output types</h3>

<p><code class="language-plaintext highlighter-rouge">Regex</code> is generic over it’s output type. What this means, is that when we define capture groups in our regex, we can actually specify them on the <code class="language-plaintext highlighter-rouge">Regex</code> as the output of the object. To do this, you provide an extra <code class="language-plaintext highlighter-rouge">as:</code> argument to the initializer, where you specify a tuple type of what you’re expecting. Most of the time this will be a tuple of two or more <code class="language-plaintext highlighter-rouge">Substring</code>s.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">Regex</span><span class="p">(</span><span class="err">#</span><span class="s">"(CREDIT|DEBIT)</span><span class="err">\</span><span class="s">s+"</span><span class="err">#</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="p">(</span><span class="kt">Substring</span><span class="p">,</span> <span class="kt">Substring</span><span class="p">)</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Notice that I specified a tuple of two <code class="language-plaintext highlighter-rouge">Substring</code>s even though I only have one capture group. That is because the first captured of the regex is always the whole string that was matched. Which is then followed by all of the explicit capture groups.</p>

<p>If I wanted to also capture the first number of the date in the following column, I would use a regex like this</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">Regex</span><span class="p">(</span><span class="err">#</span><span class="s">"(CREDIT|DEBIT)</span><span class="err">\</span><span class="s">s+(</span><span class="err">\</span><span class="s">+d)"</span><span class="err">#</span><span class="p">,</span> <span class="nv">as</span><span class="p">:</span> <span class="p">(</span><span class="kt">Substring</span><span class="p">,</span> <span class="kt">Substring</span><span class="p">,</span> <span class="kt">Substring</span><span class="p">)</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Do get that number out of the match, I would simply access the tuple element on the match object like so.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">match</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="nf">firstMatch</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">regex</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">month</span> <span class="o">=</span> <span class="n">match</span><span class="p">?</span><span class="o">.</span><span class="mi">2</span>  <span class="c1">// "03"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The type of <code class="language-plaintext highlighter-rouge">month</code> will be <code class="language-plaintext highlighter-rouge">Substring?</code>. I can similarly get the first column by accessing <code class="language-plaintext highlighter-rouge">match?.1</code>, or the whole matched string with <code class="language-plaintext highlighter-rouge">match?.0</code>.</p>

<p>If I wanted to get a list of all the values in the first column I could do something like ths</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">transactionTypes</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="nf">matches</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">regex</span><span class="p">)</span><span class="o">.</span><span class="nf">map</span><span class="p">(\</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span>  <span class="c1">// ["CREDIT", "CREDIT", "DEBIT", "DEBIT"]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Hopefully you can see how this is an improvement over Foundation’s <code class="language-plaintext highlighter-rouge">NSRegularExpression</code>, however it doesn’t stop there.</p>

<h2 id="regex-literals">Regex Literals</h2>

<p>With <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0354-regex-literals.md">SE-0354</a> the Swift team introduced a new syntax for defining regex patterns called Regex Literals. Let’s take a look at it in this section.</p>

<p>If I wanted to define the exact same pattern that we had in the previous example, using regex literals it would look as follows</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="sr">/(CREDIT|DEBIT)\s+(\d+)/</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>As you can see, it is literally the raw regex pattern surrounded by forward slashes (<code class="language-plaintext highlighter-rouge">/</code>). One benefit of defining a regex patterns this way rather than creating the raw <code class="language-plaintext highlighter-rouge">Regex</code> type is that these literals are checked at compile time. This means if you make an error, you will see it right away, so you don’t need any <code class="language-plaintext highlighter-rouge">try</code>s. It also means that the Swift compiler can analyze your pattern and figure out the correct return type for the regex.</p>

<p>If we look at the type of <code class="language-plaintext highlighter-rouge">regex</code> with <code class="language-plaintext highlighter-rouge">print(type(of: regex))</code> we would see <code class="language-plaintext highlighter-rouge">Regex&lt;(Substring, Substring, Substring)&gt;</code>. As you can see, the compiler was able to automatically determine the type of the pattern, without us having to specify it manually. You can also see that the type that regex literals create is still a <code class="language-plaintext highlighter-rouge">Regex</code>, so its usage is exactly the same as in the previous example.</p>

<h3 id="extended-literal-delimiters">Extended Literal Delimiters</h3>

<p>There is one gotcha that I should mention, and that is the fact that forward slashes must be escaped when using regex literals. Let me show you what I mean. Below is a sample of what a row in our data looks like, in case you forgot.</p>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">CREDIT    03/02/2022    Payroll                   $200.23</code></pre></figure>

<p>If we wanted to grab the entire date from the second column, the regex pattern for that would look like so</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="sr">/(CREDIT|DEBIT)\s+(\d+)/(\d+)/(\d+)/</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>However this would not work. Notice the forward slashes in <code class="language-plaintext highlighter-rouge">(\d+)/(\d+)/(\d+)</code>. Because regex literal are delimited by forward slashes, the compiler is likely to be yelling all kinds of errors at you right now. To make this work, we have to escape the forward slashes (<code class="language-plaintext highlighter-rouge">/</code>) with backslashes (<code class="language-plaintext highlighter-rouge">\</code>). So our escaped regex looks like this</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="sr">/(CREDIT|DEBIT)\s+(\d+)\/(\d+)\/(\d+)/</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is a little difficult to work with in my opinion. Which is why the Swift team decided to enable the same kind of extended delimiters that they made for string literals, but for regex literals. So to avoid the backslash escaping we can do</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="sr">#/(CREDIT|DEBIT)\s+(\d+)/(\d+)/(\d+)/#</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>One hidden feature of using these regex delimiters is that all whitespace and newlines in the regex are ignored. This means that you can break it up across multiple lines to make it more readable. Not only that but you can actually leave comments within your regex with by starting it with <code class="language-plaintext highlighter-rouge">#</code>.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="sr">#/
  (CREDIT|DEBIT)     </span><span class="c1"># transaction type</span><span class="sr">
  \s+
  (\d+)/(\d+)/(\d+)  </span><span class="c1"># date</span><span class="sr">
/#</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>I find this to be way more readable than the string regex patterns that we were using before.</p>

<p>Of course as mentioned before, this produces a <code class="language-plaintext highlighter-rouge">Regex</code> type, so usage is the same as before.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">match</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="nf">firstMatch</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">regex</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">month</span> <span class="o">=</span> <span class="n">match</span><span class="p">?</span><span class="o">.</span><span class="mi">2</span>  <span class="c1">// "03"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="named-capture-groups">Named Capture Groups</h3>

<p>Notice how we have to use numbers to refer to our capture groups. Another benefit of using regex literals is allowing you to name the capture groups. This is done by adding a <code class="language-plaintext highlighter-rouge">?</code> after the opening parenthesis and providing the name between angle brackets right after that.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="sr">#/
  (?&lt;transactionType&gt; CREDIT|DEBIT)          </span><span class="c1"># transaction type</span><span class="sr">
  \s+
  (?&lt;month&gt; \d+)/(?&lt;day&gt; \d+)/(?&lt;year&gt; \d+)  </span><span class="c1"># date</span><span class="sr">
/#</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Now, when we access the capture groups we can use the names we specify in the regex, rather than the number of their position.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">match</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="nf">firstMatch</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">regex</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">month</span> <span class="o">=</span> <span class="n">match</span><span class="p">?</span><span class="o">.</span><span class="n">month</span>  <span class="c1">// "03"</span>
<span class="k">let</span> <span class="nv">year</span> <span class="o">=</span> <span class="n">match</span><span class="p">?</span><span class="o">.</span><span class="n">year</span>    <span class="c1">// "02"</span>
<span class="k">let</span> <span class="nv">day</span> <span class="o">=</span> <span class="n">match</span><span class="p">?</span><span class="o">.</span><span class="n">day</span>      <span class="c1">// "2022"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is definitely an improvement over what Foundation offered. But wait, there’s more!</p>

<h2 id="regexbuilder"><code class="language-plaintext highlighter-rouge">RegexBuilder</code></h2>

<p>Along with regex literals, the Swift team introduced the <a href="https://developer.apple.com/documentation/regexbuilder"><code class="language-plaintext highlighter-rouge">RegexBuilder</code></a> framework. This is a framework that let’s us define regex patterns using Swift’s result builder syntax, similar to how we define views in SwiftUI.</p>

<p>Let’s define the same pattern we were working with, using <code class="language-plaintext highlighter-rouge">RegexBuilder</code> this time.</p>

<p>First we import the framework.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="kd">import</span> <span class="kt">RegexBuilder</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Next we start a pattern definition. We will define our pattern within the curly braces.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="kt">Regex</span> <span class="p">{</span>

<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Let’s look at the first part of the regex.</p>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">(CREDIT|DEBIT)</code></pre></figure>

<p>This says, look for <strong>either</strong> the whole string <strong><code class="language-plaintext highlighter-rouge">CREDIT</code></strong> or the whole string <strong><code class="language-plaintext highlighter-rouge">DEBIT</code></strong> and then <strong>capture</strong> that. To achieve the same thing with <code class="language-plaintext highlighter-rouge">RegexBuilder</code>, we quite literally just say what we want.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="kt">Regex</span> <span class="p">{</span>
  <span class="kt">Capture</span> <span class="p">{</span>
    <span class="kt">ChoiceOf</span> <span class="p">{</span>
      <span class="s">"CREDIT"</span>
      <span class="s">"DEBIT"</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Notice how much more descriptive this approach is. Rather than using the cryptic regex syntax, we just use normal english words to describe what we’re trying to do. When you’re coming back six months from now, you won’t need to pull out a regex handbook to understand what you’re trying to do here.</p>

<p>In fact I bet that you can understand the rest of the pattern without me explaining much of it.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="kt">Regex</span> <span class="p">{</span>
  <span class="c1">// Transaction type</span>
  <span class="kt">Capture</span> <span class="p">{</span>
    <span class="kt">ChoiceOf</span> <span class="p">{</span>
      <span class="s">"CREDIT"</span>
      <span class="s">"DEBIT"</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">OneOrMore</span> <span class="p">{</span>
    <span class="kt">CharacterClass</span><span class="o">.</span><span class="n">whitespace</span>
  <span class="p">}</span>

  <span class="c1">// Date</span>
  <span class="kt">Capture</span> <span class="p">{</span>
    <span class="kt">OneOrMore</span> <span class="p">{</span>
      <span class="kt">CharacterClass</span><span class="o">.</span><span class="n">digit</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="s">"/"</span>
  <span class="kt">Capture</span> <span class="p">{</span>
    <span class="kt">OneOrMore</span> <span class="p">{</span>
      <span class="kt">CharacterClass</span><span class="o">.</span><span class="n">digit</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="s">"/"</span>
  <span class="kt">Capture</span> <span class="p">{</span>
    <span class="kt">OneOrMore</span> <span class="p">{</span>
      <span class="kt">CharacterClass</span><span class="o">.</span><span class="n">digit</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There are a few things to notice here. First, since this is just plain Swift code, we can leave inline comments, like we would anywhere else.</p>

<p>Second, we use common constructs like <code class="language-plaintext highlighter-rouge">Capture</code>, <code class="language-plaintext highlighter-rouge">OneOrMore</code> and <code class="language-plaintext highlighter-rouge">ChoiceOf</code>, that if you’re familiar with you know right away what they do, and if not, then it’s easy to guess based on the name. It’s intuitive.</p>

<p>Third, since this is using Swift’s result builders, we can compose different regex patterns together, similar to how you’d extract repetitive View code in SwiftUI.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">digitCapture</span> <span class="o">=</span> <span class="kt">Regex</span> <span class="p">{</span>
  <span class="kt">Capture</span> <span class="p">{</span>
    <span class="kt">OneOrMore</span> <span class="p">{</span>
      <span class="kt">CharacterClass</span><span class="o">.</span><span class="n">digit</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="kt">Regex</span> <span class="p">{</span>
  <span class="c1">// Transaction type</span>
  <span class="kt">Capture</span> <span class="p">{</span>
    <span class="kt">ChoiceOf</span> <span class="p">{</span>
      <span class="s">"CREDIT"</span>
      <span class="s">"DEBIT"</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">OneOrMore</span> <span class="p">{</span>
    <span class="kt">CharacterClass</span><span class="o">.</span><span class="n">whitespace</span>
  <span class="p">}</span>

  <span class="c1">// Date</span>
  <span class="n">digitCapture</span>
  <span class="s">"/"</span>
  <span class="n">digitCapture</span>
  <span class="s">"/"</span>
  <span class="n">digitCapture</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In terms of usage this is a still that same <code class="language-plaintext highlighter-rouge">Regex</code> type. So we use <code class="language-plaintext highlighter-rouge">regex</code> in exactly the same way as we did before. Except since we haven’t named our captures yet, we must use the tuple indices.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">match</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="nf">firstMatch</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">regex</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">month</span> <span class="o">=</span> <span class="n">match</span><span class="p">?</span><span class="o">.</span><span class="mi">2</span>  <span class="c1">// "03"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The string API exposes an additional set of methods that allow us to pass in regex builders directly. This is particularly useful when your regex is short.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">match</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="n">firstMatch</span> <span class="p">{</span>
  <span class="kt">Capture</span> <span class="p">{</span>
    <span class="kt">ChoiceOf</span> <span class="p">{</span>
      <span class="s">"CREDIT"</span>
      <span class="s">"DEBIT"</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">transactionType</span> <span class="o">=</span> <span class="n">match</span><span class="p">?</span><span class="o">.</span><span class="mi">1</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="naming-capture-groups">Naming Capture Groups</h3>

<p>When it comes to naming capture groups, this works a little different from the other examples. First, we must define a <code class="language-plaintext highlighter-rouge">Reference</code> that will act as the gluing component between defining the capture group, and actually getting the values out.</p>

<p>Let’s define a reference for the transaction type group.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">transactionTypeRef</span> <span class="o">=</span> <span class="kt">Reference</span><span class="p">(</span><span class="kt">Substring</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>When defining a reference, you must specify what kind of data it is capturing. For most purposes this will be <code class="language-plaintext highlighter-rouge">Substring</code>, however there is a way to use a custom type. More on that later.</p>

<p>We then use the reference in our regex to associate a particular <code class="language-plaintext highlighter-rouge">Capture</code> with this reference. We do this by supplying the reference as an argument to the <code class="language-plaintext highlighter-rouge">Capture</code> expression.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="kt">Capture</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="n">transactionTypeRef</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">ChoiceOf</span> <span class="p">{</span>
    <span class="s">"CREDIT"</span>
    <span class="s">"DEBIT"</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If we try to access the transaction type from a match using the tuple index, it will not work. Neither will <code class="language-plaintext highlighter-rouge">match.transactionType</code>. Unfortunately that is not possible. Instead, we have to access data on the match object as if it’s a dictionary.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">match</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="nf">firstMatch</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">regex</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">transactionType</span> <span class="o">=</span> <span class="n">match</span><span class="p">?[</span><span class="n">transactionTypeRef</span><span class="p">]</span>  <span class="c1">// "CREDIT"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This returns an optional <code class="language-plaintext highlighter-rouge">Substring</code>, just like the output type of our <code class="language-plaintext highlighter-rouge">transactionTypeRef</code>.</p>

<p>We can repeat this process for the date fields, turning the extrapolated <code class="language-plaintext highlighter-rouge">digitCapture</code> property into a function. Here’s what that would look like.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">transactionTypeRef</span> <span class="o">=</span> <span class="kt">Reference</span><span class="p">(</span><span class="kt">Substring</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">dayRef</span> <span class="o">=</span> <span class="kt">Reference</span><span class="p">(</span><span class="kt">Substring</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">monthRef</span> <span class="o">=</span> <span class="kt">Reference</span><span class="p">(</span><span class="kt">Substring</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">yearRef</span> <span class="o">=</span> <span class="kt">Reference</span><span class="p">(</span><span class="kt">Substring</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">digitCapture</span><span class="p">(</span><span class="k">as</span> <span class="nv">ref</span><span class="p">:</span> <span class="kt">Reference</span><span class="o">&lt;</span><span class="kt">Substring</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kd">some</span> <span class="kt">RegexComponent</span> <span class="p">{</span>
  <span class="kt">Capture</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">OneOrMore</span> <span class="p">{</span>
      <span class="kt">CharacterClass</span><span class="o">.</span><span class="n">digit</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="kt">Regex</span> <span class="p">{</span>
  <span class="kt">Capture</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="n">transactionTypeRef</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">ChoiceOf</span> <span class="p">{</span>
      <span class="s">"CREDIT"</span>
      <span class="s">"DEBIT"</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kt">OneOrMore</span> <span class="p">{</span>
    <span class="kt">CharacterClass</span><span class="o">.</span><span class="n">whitespace</span>
  <span class="p">}</span>
  <span class="nf">digitCapture</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="n">monthRef</span><span class="p">)</span>
  <span class="s">"/"</span>
  <span class="nf">digitCapture</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="n">dayRef</span><span class="p">)</span>
  <span class="s">"/"</span>
  <span class="nf">digitCapture</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="n">yearRef</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Notice here that we specified a return type of <code class="language-plaintext highlighter-rouge">some RegexComponent</code> for the <code class="language-plaintext highlighter-rouge">digitCapture</code> function. This again is very similar to how SwiftUI works, where we specify a return type of <code class="language-plaintext highlighter-rouge">some View</code> for custom views. We could of course use a concrete <code class="language-plaintext highlighter-rouge">Regex</code> type, but then we would need to figure out a concrete return type from our builder expression anytime the pattern changes, and unfortunately it’s not as simple as <code class="language-plaintext highlighter-rouge">Regex&lt;(Substring, Substring)&gt;</code>.</p>

<p>Notice also that we didn’t need to wrap our digit capture pattern in a <code class="language-plaintext highlighter-rouge">Regex { ... }</code> block. That is because <code class="language-plaintext highlighter-rouge">Capture</code> along with most other Regex Builder blocks all conform to <code class="language-plaintext highlighter-rouge">RegexComponent</code>. This can save you some code when composing regex patterns together.</p>

<p>With this code in place, we should be able to read all the captured fields in the regex.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">match</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="nf">firstMatch</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">regex</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">transactionType</span> <span class="o">=</span> <span class="n">match</span><span class="p">?[</span><span class="n">transactionTypeRef</span><span class="p">]</span>  <span class="c1">// "CREDIT"</span>
<span class="k">let</span> <span class="nv">year</span> <span class="o">=</span> <span class="n">match</span><span class="p">?[</span><span class="n">yearRef</span><span class="p">]</span>                        <span class="c1">// "2022"</span>
<span class="k">let</span> <span class="nv">day</span> <span class="o">=</span> <span class="n">match</span><span class="p">?[</span><span class="n">dayRef</span><span class="p">]</span>                          <span class="c1">// "02"</span>
<span class="k">let</span> <span class="nv">month</span> <span class="o">=</span> <span class="n">match</span><span class="p">?[</span><span class="n">monthRef</span><span class="p">]</span>                      <span class="c1">// "03"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="capturing-custom-types">Capturing Custom Types</h3>

<p>The last thing that I want to mention has to do with string parsing. We can use these regex patterns to fish out parts of strings, but this just gives us <code class="language-plaintext highlighter-rouge">Substring</code>s. There is a way to have the regex pattern transform those <code class="language-plaintext highlighter-rouge">Substring</code>s into custom data types for us. Let’s look at how we can do that.</p>

<p>Let’s assume that we have a custom <code class="language-plaintext highlighter-rouge">enum</code> to represent the different kinds of transactions that we can encounter.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="kd">enum</span> <span class="kt">TransactionType</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">credit</span> <span class="o">=</span> <span class="s">"CREDIT"</span>
  <span class="k">case</span> <span class="n">debit</span> <span class="o">=</span> <span class="s">"DEBIT"</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can specify a transformation function in our regex, which will take the captured <code class="language-plaintext highlighter-rouge">CREDIT</code> or <code class="language-plaintext highlighter-rouge">DEBIT</code> strings and automatically turn them into our <code class="language-plaintext highlighter-rouge">TransactionType.credit</code> or <code class="language-plaintext highlighter-rouge">.debit</code> instances.</p>

<p>To do this, we change our <code class="language-plaintext highlighter-rouge">CREDIT</code>/<code class="language-plaintext highlighter-rouge">DEBIT</code> capture regex to something like this</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="kt">TryCapture</span><span class="p">(</span><span class="nv">as</span><span class="p">:</span> <span class="n">transactionTypeRef</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">ChoiceOf</span> <span class="p">{</span>
    <span class="s">"CREDIT"</span>
    <span class="s">"DEBIT"</span>
  <span class="p">}</span>
<span class="p">}</span> <span class="nv">transform</span><span class="p">:</span> <span class="p">{</span> <span class="n">substring</span> <span class="k">in</span>
  <span class="kt">TransactionType</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="kt">String</span><span class="p">(</span><span class="n">substring</span><span class="p">))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The way this works is the <code class="language-plaintext highlighter-rouge">TryCapture</code> will take in whatever it matches within its first <code class="language-plaintext highlighter-rouge">{ ... }</code> block, and pass that to the transform function as the first argument. The type of this argument will be <code class="language-plaintext highlighter-rouge">Substring</code>. From there you simply parse it into whatever custom type you want and return that. The return type of the transform function is optional so you can return nil if the substring doesn’t match. You can even throw errors in there.</p>

<p>One last change still remains, and that is to change the output type of our reference. Replace <code class="language-plaintext highlighter-rouge">Substring.self</code> with <code class="language-plaintext highlighter-rouge">TransactionType.self</code> in the definition of <code class="language-plaintext highlighter-rouge">transactionTypeRef</code>.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="nv">transactionTypeRef</span> <span class="o">=</span> <span class="kt">Reference</span><span class="p">(</span><span class="kt">TransactionType</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>  <span class="c1">// TransactionType.credit</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Now when you access the transaction type from a match object, rather than returning a <code class="language-plaintext highlighter-rouge">Substring</code> instance, you should get a <code class="language-plaintext highlighter-rouge">TransactionType</code> instance.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This was an overview of the changes and improvements introduced to working with regex in Swift. I hope you find this article useful.</p>

<h3 id="sources">Sources</h3>

<ul>
  <li><a href="https://developer.apple.com/documentation/foundation/nsregularexpression">NSRegularExpression</a></li>
  <li><a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters/#Extended-String-Delimiters">Extended String Delimiters</a></li>
  <li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0350-regex-type-overview.md">SE-0350 - Regex Type Overview</a></li>
  <li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0351-regex-builder.md">SE-0351 - Regex Builder</a></li>
  <li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0354-regex-literals.md">SE-0354 - Regex Literals</a></li>
  <li><a href="https://developer.apple.com/documentation/swift/regex">Regex</a></li>
  <li><a href="https://developer.apple.com/documentation/regexbuilder">RegexBuilder</a></li>
</ul>

</article>

  <footer>
  © 2023 Inal Gotov
  <br>
  <a href="/index.html">Home</a> | <a href="/articles.html">Articles</a> | <a href="/feed.xml">RSS</a>
  <br>
  <a href="/privacy.html">Privacy Policy</a> | <a href="/resume.html">Résumé</a>
</footer>

</body>
</html>
